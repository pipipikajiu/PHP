## 1 . 什么是抽象方法
```javascript
抽象方法 : 没有方法体 {} 的方法，必须使用abstract 关键字修饰.
abstract function say(); //    抽象方法
```

## 2 . 什么是抽象类
```javascript
抽象类 :包含 抽象方法 的 类 就叫抽象类。抽象类必须使用abstract关键字修饰。
 abstract class Person{}

 使用抽象类的目的 : 就是限制实例化！因为抽象类中可能包含抽象方法,而抽象方法没有方法体,实例化调用没有意义.

 注意 :  1 . 抽象类 并不一定必须包含抽象方法 可以包含非抽象方法；
        2 . 包含抽象方法的类，一定是抽象类；
        3 . 
        4 . 抽象类，不能实例化。 
        5 . 子类继承抽象类，那么子类必须重写父类的所有抽象方法.除非子类也是抽象类.
        6 . 子类继承一个抽象类，则必须 包含 并且 实现 抽象类中已定的抽象方法。
```
## 3 . 静态属性表和静态方法

```javascript
- 3.1 . static : 修饰 属性 和 方法
        - 3.1.1 . 可以修饰属性和方法,分别称为 静态属性 静态方法  也叫 类属性,类方法.
        - 3.1.2 . 怎样调用静态属性 静态方法 : 只能用 类名 直接调用 ,在类中,可以用self(代指类名)调用. self :: $sex;
        - 3.1.3 . 静态方法中,不能调用 非静态属性 或方法 , 但是 非静态方法中 , 可以调用静态属性和方法.
        - 3.1.4 . 静态属性表和静态方法,在 类 装在时就会声明, 先于对象产生.
        - 3.1.5 . 静态属性是共享的.也就是new很多对象也是共用一个属性.
- 3.2 . final : 修饰 类 和 方法 ,为最终类/最终方法, 不能被继承/不能被重写.不能修饰属性.
- 3.3 . const 关键字 : 在类中声明常量.
        在类中声明常量，不能使用define()函数!必须使用const关键字。
           与define()声明类似，const关键字声明常量不能带$，必须全部大写！
           常量一旦声明，不能改变。调用时与static一样，使用类名帝爱用 Person：：常量.
- 3.4 . :: ① 使用parent关键字，调用父类中的同名方法；parent::say();
      　    ② 使用类名(和self)调用类中的静态属性、静态方法、以及常量。
      

                  
```
```javascript
define(name,value,case_insensitive) 函数定义一个常量.
name : 必需,规定常量的名称.
value : 必需,规定常量的值.
case_insensitive : 可选,规定常量的名称是否对大小写敏感.若设置为 true，则对大小写不敏感。默认是 false（大小写敏感）.

constant(constant) 函数返回一个常量的值.
constant : 必需,规定要检查的常量的名称.
```

## 4 . 串行化与反串行化(序列化与反序列化)
```javascript
- 4.1 . 串行化 : 将对象转化为一个字符串的过程;
- 4.2 . 反串行化 : 将串行化后的字符串,转化为对象的过程;
- 4.3 . 声明时候使用串行化 : 
        1 . 对象需要在网络中传输的时候;
        2 . 对象需要在文件或者数据库中持久保存的时候.
- 4.4 . 实现对象串行化与反串行化 : 
        串行化 : $str = serialize($duixiang);
        反串行化： $duixiang = unserialize($str);
-4.5 . _sleep() : 魔术方法 :
        1 . 执行串行化时,会 自动 执行 _sleep() 函数;
        2 . _sleep() 要求返回一个 数组, 数组中的值,为可串行化的属性,不在数组中的属性,能被串行化;
            function _sleep(){
                    return array('name','age');
            }
- 4.6 . __wakeup()魔术方法：
        1 : 当反串行化对象时，自动调用__wakeup()方法；
        2 : 自动调用时，用于给反串行化产生的新对象属性，进行重新复制；
                function __wakeup(){
                      $this->name = "李四";
                }
                
```
