## 1. for,foreach,array_walk 
- 1 . foreach 的效率要比 for 高很多,原因: for 要进行很多次条件判断。循环内要调用函数，用 array_walk 最好，它的效率要比 for 高出1倍，要比 foreach 高出43%的效率.
## 2. isset empty is_null的区别
- 2 .isset 判断变量是否已存在,empty 判断变量是否为空或为0或null或false,is_null 判断变量是否为NULL 
## 3.  常用的数组函数,5个以上,并说明作用:
```javascript
- 3.1 . array_change_key_case(array,case) : 把数组中所有键更改为小写或大写. 
            array	必需。规定要使用的数组.
            case     可选。可能的值：
            CASE_LOWER - 将数组的键转换为小写字母(默认值.).
            CASE_UPPER - 将数组的键转换为大写字母.

- 3.2 . PHP array_chunk(array,size,preserve_key) : 把一个数组分割为新的数组块.
            size : 一个数组 中放几个元素,size是几 一个数组中就放几个元素;
            preserve_key : 可选
                            true - 保留原始数组中的 键名 .
                            false - 每个结果数组使用从零开始的新数组索引(默认)。

- 3.3 . array_column(array,column_key,index_key) : 返回数组中某个单一列的值.
           column_key : 必选 需要返回值 的 列;
           index_key : 可选 用作返回数组的索引/键 的 列。

- 3.4 . array_combine(keys,values) : 通过合并两个数组来创建一个新数组，其中的一个数组元素为键名，另一个数组元素为键值：

- 3.5 . array_count_values(array)： 统计数组中所有值出现的次数:
          返回值 ：返回关联数组，其元素的  键名  是原数组的 值，键值是该值在原数组中出现的次数.

- 3.6 . array_diff(array1,array2,array3...):比较两个数组的 键值，并返回差集：
        array_diff_assoc()：比较数组，返回差集（比较键名和键值）。
        array_diff_key()：比较数组，返回差集（只比较键名）。
        array_diff_uassoc()：比较数组，返回差集（比较键名和键值，使用用户自定义的键名比较函数）
         仅比较 值  且只返回第一个数组和其他数组不同(不同和多的) 的键值.

- 3.7 . array_filter(array,callbackfunction)：用回调函数过滤数组中的元素.

- 3.8 . array_flip(array): 交换数组中的键和值.
        如果反转成功，则返回反转后的数组. 如果失败，则返回 NULL.
        
        更多 : https://blog.csdn.net/lbwo001/article/details/52778242
```
## 4. 开发中接触过的设计模式,两种以上:
```javascript

```
## 5. 什么是CSRF攻击?什么是XSS攻击,怎么防范.
- . (http://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html)
- . https://www.2cto.com/article/200712/22519.html
```javascript
- 5.1 . CSRF/XSRF : 跨站请求伪造
        CSRF攻击是源于WEB的隐式身份验证机制！WEB的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的！
        CSRF防御:
            CSRF的防御可以从服务端和客户端两方面着手，防御效果是从服务端着手效果比较好:
                服务端的CSRF方式总的思想都是一致的，就是在 客户端页面 增加伪随机数:
                    (1).Cookie Hashing(所有表单都包含同一个伪随机值)：
                        在服务端设置一个加密的cookie,然后在 表单里添加一个隐藏框(hidden),值为Hash值(md5加密后的cookie)，以认证这确实是用户发送的请求. 用户发送请求后,与服务器端的hash值进行比较.(md5是目前应用最广泛的Hash算法)
                        注 : .用户的Cookie很容易由于网站的XSS漏洞而被盗取，该方法不是最好的.
                    (2).验证码 : 
                        每次的用户提交都需要用户在表单中填写一个图片上的随机字符串，这个方案可以完全解决CSRF
                    (3).One-Time Tokens(不同的表单包含一个不同的伪随机值)
                    (4).WEB表单结构：
                    (5).服务端核对令牌：
https://blog.csdn.net/ghsau/article/details/17027893
- 5.2 . XSS攻击 : 跨站脚本攻击,可以盗取用户Cookie、破坏页面结构、重定向到其它网站等,理论上，所有可输入的地方没有对输入数据进行处理的话，都会存在XSS漏洞，
                  XSS漏洞分为两种，一种是DOM Based XSS漏洞(基于网页DOM结构的攻击，该攻击只能让少数人中招,属于非持久型)，另一种是Stored XSS漏洞(存储式XSS漏洞，攻击代码已经存储到服务器上或者数据库中，受害者是很多人,属于持久型).
        xss攻击防御:
                    1 . 需要对用户的输入进行处理，只允许输入合法的值，其它值一概过滤掉
                    2 . 如果不能对用户数据进行严格的过滤，也需要对标签进行转换,例如:< - &lt & - &amp 等.
                    3 . Html encode : StringEscapeUtils.escapeHtml(str);// 汉字会转换成对应的ASCII码，空格不转换
                                      自己写函数实现转换，只转换部分字符

```
## 6. 不用php内置函数,反转字符串,例如:'abcdefg' => 'gfedcba'

```javascript
内置函数 : strrev(string);

$s = 'strlen,substr,count';
$o = '';
$i = 0;
while(isset($s[$i]) && $s[$i] != null) {
    $o = $s[$i++].$o;
}
echo $o; 

```
## 7. 不用新变量直接交换现有两个变量的值

```javascript
- 7.1 . 字符串版本 结合使用substr，strlen两个方法实现
        substr(string,start,length) : 返回字符串的一部分. 必选 : string,start,可选 : length. 如果 start 参数是负数且 length 小于或等于 start，则 length 为 0。
        strlen(string) : 返回字符串的长度.
demo : 
        $a="a454544545";
        $b="b33633";
        echo '交换前 $a:'.$a.',$b:'.$b.'<br />';
        $a.=$b;
        // var_dump(strlen($a)-strlen($b));die();
        $b=substr($a,0,(strlen($a)-strlen($b)));
        $a=substr($a, strlen($b));
        echo '交换后$a:'.$a.',$b:'.$b.'<br />';

- 7.2 . 字符串版本 使用str_replace方法实现:
        str_replace(find,replace,string,count) :
demo : 
        $a="a";
        $b="b";
        echo '交换前 $a:'.$a.',$b:'.$b.'<br />';
        $a.=$b;
        $b=str_replace($b, "", $a);
        $a=str_replace($b, "", $a);
        echo '交换后$a:'.$a.',$b:'.$b.'<br />';

- 7.3 . 字符串版本 结合使用list方法和array实现:
demo : 
        $a="a";
        $b="b";
        echo '交换前 $a:'.$a.',$b:'.$b.'<br />';
        list($b,$a)=array($a,$b);
        echo '交换后$a:'.$a.',$b:'.$b.'<br />';

- 7.4 . 字符串和数字都适用 使用异或运算:
demo : 
        $a='a';
        $b='b';
        echo '交换前 $a:'.$a.',$b:'.$b.'<br />';
        $a=$a^$b;
        $b=$b^$a;
        $a=$a^$b;
        echo '交换后$a:'.$a.',$b:'.$b.'<br />';

- 7.5 . 只适用于数字:
demo : 
        $a=3;
        $b=5;
        echo '交换前 $a:'.$a.',$b:'.$b.'<br />';
        $a=$a+$b;
        $b=$a-$b;
        $a=$a-$b;
        echo '交换后$a:'.$a.',$b:'.$b.'<br />';
```
## 8. 写个函数来解决多线程同时读写一个文件问题:
```javascript

        1 关键函数：
        2 fopen()  // 打开文件或一个http地址，形成一个文件流
        3 flock()　　// 对文件加锁及解锁
        4 fwrite()　　// 对文件读写操作
        5 fclose()　　// 关闭文件流

      - . is_writable(file) 函数判断指定的文件是否可写。 如果文件存在并且可写则返回 true。file 参数可以是一个允许进行是否可写检查的目录名。

      - . fopen(filename,mode,include_path,context) : 打开文件或者 URL.
如果打开失败，本函数返回 FALSE。
        (filename : 必需,规定要打开的文件或 URL。
        mode : 必需。规定要求到该文件/流的访问类型。可能的值见下表。
        include_path : 可选,如果也需要在 include_path 中检索文件的话，可以将该参数设为 1 或 TRUE。
        context : 可选。规定文件句柄的环境。Context 是可以修改流的行为的一套选项.)

        - . flock(file,lock,block) : 锁定或释放文件.若成功，则返回 true。若失败，则返回 false。
            file : 必需。规定要锁定或释放的已打开的文件;
            lock : 必需。规定要使用哪种锁定类型。
            block : 可选。若设置为 1 或 true，则当进行锁定时阻挡其他进程。

            说明
                flock() 操作的 file 必须是一个已经打开的文件指针。
                lock 参数可以是以下值之一：

                要取得共享锁定（读取的程序），将 lock 设为 LOCK_SH
                要取得独占锁定（写入的程序），将 lock 设为 LOCK_EX
                要释放锁定（无论共享或独占），将 lock 设为 LOCK_UN
                如果不希望 flock() 在锁定时堵塞，则给 lock 加上 LOCK_NB
        
        - . fwrite(file,string,length) : 函数写入文件,成功返回写入的字符数，出现错误时则返回 false。
                file : 必需。规定要写入的打开文件。
                string : 必需。规定要写入文件的字符串。
                length : 可选。规定要写入的最大字节数。 如果指定了 length，当写入了 length 个字节或者写完了 string 以后，写入就会停止.
        - . fclose(file) : 关闭一个打开文件.
```
https://blog.csdn.net/sparkjin/article/details/9789401

```javascript
- 8.1 .  一般的解决方案时当一进程对文件进行操作时，首先对其它进行 加锁 ，意味着这里只有该进程有权对文件进行读取，其它进程如果现在读，是完全没有问题，但如果这时有进程试图想对其进行更新，会遭到操作拒绝，先前对文件进行加锁的进程这时如果对文件的更新操作完毕，这就释放独占的标识，这时文件又恢复到了可更改的状态。接下来同理，如果那个进程在操作文件时，文件没有加锁，这时，它就可以放心大胆的对文件进行锁定，独自享用。

        $fp = fopen("/tmp/lock.txt", "w+");  
        if (flock($fp, LOCK_EX)) {  
                fwrite($fp, "Write something here\n");  
                flock($fp, LOCK_UN);  
        } else {  
                echo "Couldn't lock the file !";  
        }  
        fclose($fp);  
        缺点 : 是经常独占资源，不即时释放，或者是根本不释放，造成死锁，从而使服务器的cpu占用很高，甚至有时候会让服务器彻底死掉。
        解决方案 : 
```
## 9. 写一个函数,尽可能有效的从一个标准url种取出扩展名.

```javascript


```

## 10. php获取文件内容的方法,对应函数.

```javascript


```

## 11. php如何获取客户端ip地址:

```javascript


```

## 12 . 用php 编写函数,列出一个目录下所有层级的文件,输入的是绝对目录路径,输出的是文件的绝对路径:

## 13 . mysql的主从同步如何做?假设主从有延迟10秒以上,需要做些什么?事务是如何影响主从同步的?

## 14 . 正则表达式 : 
- 14.1 . 手机号 :
```javascript

```
- 14.1 . 邮箱 :
```javascript

```

## 15 . 提取该日期格式下的月份 ,年份和秒(2018-01-01 00:00:00):

## 16 . 简述TCP和udp,简述HTTP请求过程,HTTPS是如何建立连接的?

```javascript
https://blog.csdn.net/xiaobangkuaipao/article/details/76793702
https://blog.csdn.net/li_ning_/article/details/52117463
https://blog.csdn.net/shennongzhaizhu/article/details/52025050
```
## 17 . 使用过哪些异步队列? 如何应对处理失败的情况?

## 18 . 如何查找redis中单个key-value 占用量很大的那些key?

## 19 . 写代码时,请求http接口,需要注意些什么?

## 20 . 找到nginx日志中访问量最高的ip 前十位,有什么方案?